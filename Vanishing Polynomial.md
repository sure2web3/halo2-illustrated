# Vanishing Polynomial
The vanishing polynomial is a key concept in polynomial commitment schemes and zero-knowledge proof systems like Halo 2. It is used to enforce constraints over a finite field by ensuring that certain conditions are satisfied at specific points. In the context of the Halo 2 protocol, the vanishing polynomial is denoted as $t(X) = (X^n - 1)$.
# What Does It Represent?
| Representation | Description | Postscript | 
|----------------|-------------|-------------|
| Roots of Unity | a. The vanishing polynomial ( $t(X)$ ) vanishes (evaluates to zero) at the roots of unity in the finite field.<br> b. For ( $t(X) = X^n - 1$ ), the roots of ( $t(X)$ ) are the $n$-th roots of unity, which are the solutions to ( $X^n = 1$ ) in the field. | 
| Circuit Constraints | a. In a zero-knowledge proof system, the circuit is represented as a set of polynomials.<br> b. The vanishing polynomial ensures that these polynomials satisfy the circuit's constraints at specific points (e.g., the roots of unity). | |
| Finite Field Arithmetic | Since the proof system operates over a finite field, the vanishing polynomial helps enforce periodicity and ensures that the constraints are well-defined within the field. | In the context of finite field arithmetic, "enforce periodicity" means that the vanishing polynomial ensures that the behavior of the system (e.g., the evaluation of polynomials) repeats in a predictable, cyclic manner over the finite field.<br><br> Explanation:<br> a. A finite field has a limited number of elements, and arithmetic operations (addition, multiplication, etc.) are performed modulo the field's size. This inherently introduces periodic or cyclic behavior.<br> b. The vanishing polynomial $t(X) = X^n - 1$ has roots that are the $n$-th roots of unity. These roots exhibit periodicity because they satisfy $X^n = 1$, meaning that after every $n$ steps (e.g., powers of $X$), the values repeat.<br> c. By using the vanishing polynomial, the proof system ensures that constraints are applied consistently within this cyclic structure, aligning with the periodic nature of the finite field.<br><br> In summary, "enforce periodicity" refers to leveraging the cyclic properties of the field to ensure that the constraints and computations behave predictably and repeat as expected. |
# How Is It Used in halo2?
| Method | Description | Postscript |
|--------|-------------|-------------|
| Constrain Circuit Relations | a. The vanishing polynomial is used to ensure that all circuit relations (e.g., gate constraints, lookup constraints, permutation constraints) evaluate to zero at the roots of unity.<br> b. For example, if a gate constraint is represented as ( $g(X)$ ), the quotient polynomial ( $h(X)$ ) is constructed as: $[ h(X) = \frac{g(X)}{t(X)} ]$. This ensures that ( $g(X)$ ) vanishes at the roots of ( t(X) ). | When we say that $g(X)$ vanishes at the roots of $t(X)$, it means that the polynomial $g(X)$ evaluates to zero at all the points where $t(X)$ evaluates to zero.<br><br> Explanation:<br> a. Roots of $t(X)$: These are the values of $X$ that make $t(X) = 0$. For the vanishing polynomial $t(X) = X^n - 1$, the roots are the $n$-th roots of unity (the solutions to $X^n = 1$ in the field).<br> b. $g(X)$ vanishes: A polynomial $g(X)$ "vanishes" at a point if substituting that point into $g(X)$ results in $g(X) = 0$.<br> c. Relation to $t(X)$: By dividing $g(X)$ by $t(X)$ (as shown in $h(X) = \frac{g(X)}{t(X)}$), we ensure that $g(X)$ has the same roots as $t(X)$. This means $g(X)$ evaluates to zero at all the roots of $t(X)$, ensuring that the constraints represented by $g(X)$ are satisfied at those specific points.<br><br> In summary, $g(X)$ vanishing at the roots of $t(X)$ ensures that the constraints encoded by $g(X)$ are enforced at the specific points (roots of $t(X)$) in the finite field. |
| Enforce Periodicity | The vanishing polynomial enforces periodicity in the circuit, ensuring that constraints are applied consistently across all rows of the circuit. | | 
| Divide Constraints | By dividing the constraints by ( $t(X)$ ), the proof system reduces the problem to checking that the quotient polynomial ( $h(X)$ ) is consistent with the commitments. | Dividing the constraints by ( t(X) ) transforms the problem of verifying that the circuit constraints are satisfied into the simpler task of checking that the quotient polynomial ( h(X) ) is consistent with the commitments. This approach ensures soundness and efficiency in the proof system. |
# Properties of the Vanishing Polynomial
| Property | Description | Postscript |
|---------|-------------|-------------|
| Degree | The degree of ( $t(X) = X^n - 1$ ) is ( $n$ ), where ( $n$ ) is the size of the circuit or the number of rows in the evaluation domain. | | 
| Roots | The roots of ( $t(X)$ ) are the $n$-th roots of unity, which are the solutions to ( $X^n = 1$ ) in the finite field. | |
| Efficient Evaluation | The vanishing polynomial can be evaluated efficiently using fast Fourier transforms (FFTs) over the roots of unity. | Fast Fourier Transforms (FFTs) are an efficient algorithm for computing the Discrete Fourier Transform (DFT) and its inverse. In the context of evaluating the vanishing polynomial, FFTs are used to perform polynomial evaluations or interpolations over the roots of unity in a highly efficient manner.<br><br> Why FFTs Are Useful:<br> a. Roots of Unity: The vanishing polynomial $t(X) = X^n - 1$ has roots that are the $n$-th roots of unity. These roots are evenly spaced in the complex plane (or finite field) and exhibit cyclic properties, making them ideal for FFT-based computations.<br> b. Efficiency: A naive evaluation of a polynomial at $n$ points would take $O(n^2)$ operations. FFTs reduce this complexity to $O(n \log n)$, which is significantly faster for large $n$.<br> c. Applications in Polynomial Arithmetic:<br> c1: Evaluation: FFTs allow the vanishing polynomial to be evaluated at all $n$-th roots of unity simultaneously.<br> c2: Interpolation: FFTs can also reconstruct a polynomial from its values at the roots of unity, enabling efficient transformations between coefficient and value representations.<br> d. Circuit Optimization: In zero-knowledge proof systems like Halo 2, FFTs are used to efficiently evaluate and manipulate polynomials over the evaluation domain (e.g., the roots of unity), which is critical for enforcing constraints and verifying proofs.<br><br> Summary:<br> FFTs leverage the cyclic structure of the roots of unity to perform polynomial evaluations and interpolations with remarkable speed, making them a cornerstone of efficient computations in cryptographic protocols and proof systems. | 
| Zero-Knowledge | The vanishing polynomial plays a role in ensuring that the proof system is zero-knowledge by hiding the prover's witness values while enforcing constraints. | The commitments and the use of $t(X)$ ensure that the verifier can only check the validity of the proof (i.e., that the constraints are satisfied) without gaining any information about the prover's private witness values. |
# Example
Suppose we have a circuit with ( n = 4 ) rows. The vanishing polynomial is $[ t(X) = X^4 - 1 ]$.

The roots of ( $t(X)$ ) are the 4-th roots of unity in the finite field, which are ( ${1, \omega, \omega^2, \omega^3}$ ), where ( $\omega$ ) is a primitive 4-th root of unity. Substituting each of these values into $t(X)$ results in $t(X) = 0$:<br>
* For $X = 1$: $t(1) = 1^4 - 1 = 0$.
* For $X = \omega$: $t(\omega) = \omega^4 - 1 = 0$ (since $\omega^4 = 1$).
* For $X = \omega^2$: $t(\omega^2) = (\omega^2)^4 - 1 = \omega^8 - 1 = 1 - 1 = 0$.
* For $X = \omega^3$: $t(\omega^3) = (\omega^3)^4 - 1 = \omega^{12} - 1 = 1 - 1 = 0$.

If a gate constraint is represented as ( $g(X)$ ), the quotient polynomial is $[ h(X) = \frac{g(X)}{t(X)} ]$

This ensures that ( $g(X)$ ) evaluates to zero at ( ${1, \omega, \omega^2, \omega^3}$ ), enforcing the circuit's constraints. $g(X)$ evaluates to zero at each of the points ${1, \omega, \omega^2, \omega^3}$. This is because $g(X)$ is constructed to be divisible by $t(X)$, and the roots of $t(X)$ are precisely the points where $t(X) = 0$. Therefore, substituting any of these roots into $g(X)$ will result in $g(X) = 0$.
# Why Is It Important?
| Reason | Description | Example |
|--------|-------------|-------------|
| Soundness | The vanishing polynomial ensures that the prover cannot cheat by providing invalid witness values. If the constraints are not satisfied, the quotient polynomial ( $h(X)$ ) will not be well-defined. | [Circuit Setup]<br><br> 1. Circuit Description:<br> a. The circuit has ( $n = 4$ ) rows.<br> b. The vanishing polynomial is: $[ t(X) = X^4 - 1 ]$<br> c. The roots of ( $t(X)$ ) are the 4th roots of unity: ( ${1, \omega, \omega^2, \omega^3}$ ), where ( $\omega$ ) is a primitive 4-th root of unity.<br> 2. Gate Constraint:<br> a. Suppose the circuit has a simple multiplication gate: $[ \text{gate}_0(X) = a_0(X) \cdot a_1(X) - a_2(X) ]$<br> b. This constraint ensures that the product of ( $a_0(X)$ ) and ( $a_1(X)$ ) equals ( $a_2(X)$ ) at all rows of the circuit.<br><br> [Prover's Witness]<br><br> 1. Valid Witness:<br> a. If the prover provides valid witness polynomials: $[ a_0(X) = 1 + X, \quad a_1(X) = 1 + X^2, \quad a_2(X) = 1 + X + X^2 + X^3 ]$<br> b. Then: $[ \text{gate}_0(X) = (1 + X) \cdot (1 + X^2) - (1 + X + X^2 + X^3) = 0 ]$<br> c. The gate constraint is satisfied, and ( $\text{gate}_0(X)$ ) is divisible by ( $t(X)$ ).<br> 2. Invalid Witness:<br> a. If the prover provides invalid witness polynomials: $[ a_0(X) = 1 + X, \quad a_1(X) = 1 + X^2, \quad a_2(X) = 1 + X + X^2 ]$<br> b. Then: $[ \text{gate}_0(X) = (1 + X) \cdot (1 + X^2) - (1 + X + X^2) = X^3 ]$<br> c. The gate constraint is not satisfied, and ( $\text{gate}_0(X)$ ) is not divisible by ( $t(X)$ ).<br><br> [Quotient Polynomial]<br><br> 1. Valid Case:<br> If the witness is valid, the quotient polynomial ( h(X) ) is well-defined: $[ h(X) = \frac{\text{gate}_0(X)}{t(X)} = 0 ]$<br> 2. Invalid Case:<br> a. If the witness is invalid, the quotient polynomial ( $h(X)$ ) is not well-defined because ( $\text{gate}_0(X)$ ) is not divisible by ( $t(X)$ ): $[ h(X) = \frac{X^3}{X^4 - 1} ]$<br> b. This results in a remainder, which the verifier will detect during the consistency check.<br><br> [Verifier's Check]<br><br> 1. Valid Witness:<br> a. The verifier checks that: $[ h(X) \cdot t(X) = \text{gate}_0(X) ]$<br> b. For a valid witness, this equation holds true.<br> 2. Invalid Witness:<br> a. For an invalid witness, the verifier finds that: $[ h(X) \cdot t(X) \neq \text{gate}_0(X) ]$<br> b. This inconsistency reveals that the prover's witness is invalid.<br><br> [Conclusion]<br><br> The vanishing polynomial ( $t(X)$ ) ensures soundness by enforcing that all circuit constraints are satisfied. If the prover provides invalid witness values, the quotient polynomial ( $h(X)$ ) will not divide evenly by ( $t(X)$ ), and the verifier will detect this inconsistency. This mechanism prevents the prover from cheating and guarantees the correctness of the proof. |
| Efficiency | By reducing the problem to evaluating polynomials at the roots of unity, the proof system can leverage FFTs for efficient computation. | [Scenario]<br><br> Suppose we have a circuit with ( $n = 8$ ) rows, and the prover needs to evaluate a polynomial ( $f(X)$ ) at all ( $n$ )-th roots of unity ( $\omega^i$ ) (where ( $\omega$ ) is a primitive ( $n$ )-th root of unity). The polynomial ( $f(X)$ ) is represented in its coefficient form: $[ f(X) = c_0 + c_1 X + c_2 X^2 + \dots + c_{n-1} X^{n-1} ]$<br><br> Directly evaluating ( $f(X)$ ) at each root of unity ( $\omega^i$ ) would require ( $O(n^2)$ ) operations, as each evaluation involves summing ( $n$ ) terms. Instead, FFTs reduce this complexity to ( $O(n \log n)$ ).<br><br> [Steps Using FFTs]<br><br> 1. Input:<br> a. The coefficients of the polynomial ( $f(X)$ ): ( $[c_0, c_1, c_2, \dots, c_{n-1}]$ ).<br> b. The ( $n$ )-th roots of unity ( $\omega^i$ ) as the evaluation domain.<br> 2. FFT for Evaluation:<br> a. The FFT algorithm transforms the polynomial from its coefficient representation to its evaluation representation at the roots of unity.<br> b. This involves recursively dividing the polynomial into even and odd terms, evaluating them separately, and combining the results efficiently.<br> 3. Output:<br> The evaluations of ( $f(X)$ ) at ( $\omega^i$ ): ( $[f(\omega^0), f(\omega^1), f(\omega^2), \dots, f(\omega^{n-1})]$ ).<br><br> [Example Calculation]<br><br> Polynomial:<br> Let ( $f(X) = 1 + 2X + 3X^2 + 4X^3$ ), and ( $n = 4$ ). The roots of unity are ( $\omega^0 = 1$ ), ( $\omega^1 = i$ ), ( $\omega^2 = -1$ ), ( $\omega^3 = -i$ ).<br><br> Direct Evaluation:<br> Evaluate ( $f(X)$ ) at each ( $\omega^i$ ):<br> $[ f(1) = 1 + 2(1) + 3(1)^2 + 4(1)^3 = 10 ]$,<br> $[ f(i) = 1 + 2(i) + 3(i^2) + 4(i^3) = 1 + 2i - 3 - 4i = -2 - 2i ]$,<br> $[ f(-1) = 1 + 2(-1) + 3(-1)^2 + 4(-1)^3 = 1 - 2 + 3 - 4 = -2 ]$,<br> $[ f(-i) = 1 + 2(-i) + 3(-i^2) + 4(-i^3) = 1 - 2i - 3 + 4i = -2 + 2i ]$<br><br> This requires ( $O(n^2) = 16$ ) operations for ( $n = 4$ ).<br><br> Using FFT:<br> 1. Split ( $f(X)$ ) into even and odd terms:<br><br> a. Even Terms:<br> a1. The even terms are the terms where the power of ( $X$ ) is an even number (e.g., $( X^0, X^2, X^4, \dots )$).<br> a2. From ( $f(X)$ ), the terms with even powers are: $[ 1 \quad (\text{coefficient of } X^0) \quad \text{and} \quad 3X^2 \quad (\text{coefficient of } X^2) ]$<br> a3. Factoring out ( $X^2$ ) from the second term, the even terms can be written as: $[ f_{\text{even}}(X) = 1 + 3X ]$, the process is: The coefficients at even indices (0, 2) are: $[ c_0 = 1 \quad (\text{from } X^0), \quad c_2 = 3 \quad (\text{from } X^2) ]$. These coefficients form the even terms: $[ f_{\text{even}}(X) = c_0 + c_2X = 1 + 3X ]$<br><br> b. Odd Terms:<br> b1. The odd terms are the terms where the power of ( $X$ ) is an odd number (e.g., $( X^1, X^3, X^5, \dots )$).<br> b2. From ( $f(X)$ ), the terms with odd powers are: $[ 2X \quad (\text{coefficient of } X^1) \quad \text{and} \quad 4X^3 \quad (\text{coefficient of } X^3) ]$<br> b3. Factoring out ( $X$ ) from both terms, the odd terms can be written as: $[ f_{\text{odd}}(X) = 2 + 4X ]$, the process is: The coefficients at odd indices (1, 3) are: $[ c_1 = 2 \quad (\text{from } X^1), \quad c_3 = 4 \quad (\text{from } X^3) ]$. These coefficients form the odd terms: $[ f_{\text{odd}}(X) = c_1 + c_3X = 2 + 4X ]$<br><br> Why Not ( 1 + 3X^2 ) and ( 2X + 4X^3 )?<br> If we were to group terms based on the powers of ( $X$ ) (e.g., $( X^0, X^2 )$ for even powers and $( X^1, X^3 )$ for odd powers), the resulting polynomials would be:<br> a. Even terms: $( f_{\text{even}}(X) = 1 + 3X^2 )$<br> b. Odd terms: $( f_{\text{odd}}(X) = 2X + 4X^3 )$<br> However, this grouping is not compatible with FFT, because FFT operates on the coefficients of the polynomial, not the powers of ( $X$ ). The FFT algorithm requires splitting the polynomial into two smaller polynomials:<br> a. One containing the coefficients at even indices.<br> b. One containing the coefficients at odd indices.<br> This structure allows FFT to recursively evaluate the polynomial at the roots of unity, reducing the computational complexity from ( $O(n^2)$ ) to ( $O(n \log n)$ ).<br><br> 2. Recursively evaluate ( $f_{\text{even}}(X)$ ) and ( $f_{\text{odd}}(X)$ ) at half the roots of unity. For $n = 4$, during recursion, the unit roots (of $n= 2$) $μ$<sub>0</sub> = 1 and $μ$<sub>1</sub> = -1 are used instead of directly substituting into the original unit roots $\omega^i$.<br><br> ( $f_{\text{even}}(\omega^0) = f_{\text{even}}(1) = 1 + 3(1) = 4$ )<br> ( $f_{\text{even}}(\omega^2) = f_{\text{even}}(-1) = 1 + 3(-1) = -2$ )<br> ( $f_{\text{odd}}(\omega^0) = f_{\text{odd}}(1) = 2 + 4(1) = 6$ )<br> ( $f_{\text{odd}}(\omega^2) = f_{\text{odd}}(-1) = 2 + 4(-1) = -2$ )<br><br> 3. Combine the results using the FFT butterfly operation, $μ^i$=$\omega^{2i}$, which is the unit root after recursion:<br> a. ( $f(\omega^i) = f_{\text{even}}(μ^i) + \omega^i \cdot f_{\text{odd}}(μ^i)$ )<br> b. ( $f(\omega^{i+n/2}) = f_{\text{even}}(μ^i) - \omega^i \cdot f_{\text{odd}}(μ^i)$ )<br><br> $f(\omega^0) = f(1) = f_{\text{even}}(\omega^0) + \omega^0 \cdot f_{\text{odd}}(\omega^0)$ ) $[ f(\omega^0) = 4 + 1 \cdot 6 = 10 ]$<br> $f(\omega^2) = f(-1) = f_{\text{even}}(\omega^0) - \omega^0 \cdot f_{\text{odd}}(\omega^0)$ ) $[ f(\omega^2) = 4 - 1 \cdot 6 = -2 $<br> $f(\omega^1) = f(i) = f_{\text{even}}(\omega^2) + \omega^1 \cdot f_{\text{odd}}(\omega^2) = -2 + i \cdot (-2) = -2 - 2i $<br> $f(\omega^3) = f(-i) = f_{\text{even}}(\omega^2) - \omega^1 \cdot f_{\text{odd}}(\omega^2) = -2 - i \cdot (-2) = -2 + 2i$<br><br> This reduces the complexity to ( $O(n \log n) = 8$ ) operations for ( $n = 4$ ).| 
| Generality | The vanishing polynomial is a general tool that can be applied to various types of constraints, including gate constraints, lookup constraints, and permutation constraints. | |
# Conclusion
The vanishing polynomial ( $t(X) = X^n - 1$ ) is a fundamental building block in the Halo 2 proving system. It ensures that all circuit constraints are satisfied at the roots of unity, enabling soundness and efficiency in the proof system. By dividing constraints by ( $t(X)$ ), the system reduces the problem to checking consistency between commitments and evaluations, forming the basis for the polynomial commitment scheme.






